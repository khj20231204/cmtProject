<!DOCTYPE html>
	<html xmlns:th="http://www.thymeleaf.org" 
	      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	      xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
	      layout:decorate="~{layouts/layout}"> 
	<head>
		<link rel="shortcut icon" href="/assets/images/logo/favicon.png" type="image/x-icon">
	    <link rel="stylesheet" href="https://uicdn.toast.com/tui.date-picker/latest/tui-date-picker.css" />
	    <!-- 기본 메타 정보 -->
	    <meta charset="UTF-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	    
	    <!-- xlsx.js (필수 의존성) -->
		<!-- <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>-->
		<!-- 최신 xlsx 스크립트 CDN -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
	   
	    <title>출고 검사</title>

<style>
  .tui-datepicker {
    z-index: 99999 !important;
    position: absolute !important;
  }
</style>

<style>
	.btn-upload { background-color: #007bff; color: white; }
	.btn-download { background-color: #28a745; color: white; } 
</style>	


</head>


<body>

    <div layout:fragment="content">
		
		<br>
<!--		<th:block th:each="soModel : ${soModel}">-->
<!--			<div th:text="${soModel}"></div>-->
<!--		</th:block>-->
<!-- 그리드 top 시작 -->
	<h3>출고 검사 목록</h3>
	
	

	
	
	
	
	
<!-- 전체 한 줄 정렬 -->
<div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; width: 100%">

  <!-- 왼쪽: 검색 + 파일 + 엑셀 -->
  <div style="display: flex; align-items: center; gap: 10px;">
    <input type="text" id="searchInput" placeholder="검색어를 입력하세요" class="form-control" style="width: 200px;" />
    
    <label for="startDate">시작일:</label>
	    <div style="position: relative;">
	      <div class="tui-datepicker-input tui-datetime-input tui-has-focus">
	        <input type="text" id="startDate" aria-label="Start Date">
	        <span class="tui-ico-date"></span>
	      </div> 
	      <div id="startDateWrapper" style="margin-top: -1px;"></div>
	    </div>
	
	    <label for="endDate">종료일:</label>
	    <div style="position: relative;">
	      <div class="tui-datepicker-input tui-datetime-input tui-has-focus">
	        <input type="text" id="endDate" aria-label="End Date">
	        <span class="tui-ico-date"></span>
	      </div>
	      <div id="endDateWrapper" style="margin-top: -1px;"></div>
	    </div>
    
    <button id="dateSearchBtn" class="btn btn-primary">검색</button>

    <!-- 파일 업로드 -->
    <input type="file" id="fileUpload" hidden>
    <input type="file" class="form-control" id="fileInput" accept=".xlsx" style="width: 300px;">

    <button class="btn btn-upload" id="ExcelUpBtn">엑셀 업로드</button>
    <button class="btn btn-download" id="ExcelDownBtn">엑셀 다운로드</button>
  </div>

  <!-- 오른쪽: 등록/삭제 -->
  <div style="display: flex; align-items: center; gap: 10px;">
    <button type="button" class="btn btn-outline-danger" onclick="deleteFqc()" sec:authorize="hasAnyRole('ADMIN', 'MANAGER')">삭제</button>
  </div>

</div>

<br>
	
	<div id="gridTop"></div>
	
	<!-- 상세 정보 영역 -->
	<div id="detailWrapper" style="margin-top: 20px; border: 1px solid #ddd; padding: 15px;">
	  <h3>상세 정보</h3>
	  <div id="detailContent">선택한 행을 클릭하면 여기에 정보가 나옵니다.</div>
	</div>
	
	
	
	
	
	
	
	


	    <script th:inline="javascript">
	    
	    const oneMonthAgo = new Date();
		  oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
		  // 시작일 DatePicker
		  const startPicker = new tui.DatePicker('#startDateWrapper', {
			language: 'ko',  
		    date: oneMonthAgo,
		    input: {
		      element: '#startDate',
		      format: 'yyyy-MM-dd'
		    }
		  });
		
		  // 종료일 DatePicker
		  const endPicker = new tui.DatePicker('#endDateWrapper', {
			language: 'ko',  
		    date: new Date(),
		    input: {
		      element: '#endDate',
		      format: 'yyyy-MM-dd'
		    }
		  });
	    

	    const grid = new tui.Grid({
            el: document.getElementById('gridTop'),
            data: /*[[${fqcList}]]*/ [],
            rowHeaders: ['checkbox'],
            pageOptions: {
    	        useClient: true,  // 서버 사이드 페이징 활성화
    	        perPage: 20
    	    },
            columns: [
            	{ 
                  header: 'NO', 
            	  name: 'fqcNo', 
            	  sortable: true, 
            	  filter: 'text', 
            	  align: "center",
            	  hidden: true
            	},
            	{
           		  header: '작업 상태',
           		  name: 'fqcInspectionStatus',
           		  align: 'center',
           		  width: 80,
           		  formatter: ({ value }) => {
           		    let btnClass = 'btn-secondary';
           		    let btnLabel = value;

           		    if (value === '진행중') {
           		      btnClass = 'btn-primary';
           		    } else if (value === '완료') {
           		      btnClass = 'btn-success';
           		    }

           		    return `<button class="btn ${btnClass} btn-sm">${btnLabel}</button>`;
           		  }
           		},
           		{
           		  header: '합격 여부',
           		  name: 'fqcInspectionResult',
           		  align: 'center',
           		  width: 80,
           		  formatter: ({ value }) => {
           		    let btnClass = 'btn-secondary';
           		    let btnLabel = '확인불가';

           		    if (value === 'P') {
           		      btnClass = 'btn-success';
           		      btnLabel = '합격';
           		    } else if (value === 'F') {
           		      btnClass = 'btn-danger';
           		      btnLabel = '불합격';
           		    }

           		    return `<button class="btn ${btnClass} btn-sm"">${btnLabel}</button>`;
           		  }
           		},
            	{ 
                  header: '출고 검사 코드', 
            	  name: 'fqcCode', 
            	  sortable: true, 
            	  filter: 'text', 
            	  width: 100,
            	  align: "center" 
            	},       	
            	{ 
                  header: '검사이름', 
              	  name: 'qcmName', 
              	  sortable: true, 
              	  filter: 'text', 
              	  align: "center",
              	},
              	{ 
                  header: '검수자', 
               	  name: 'empName', 
               	  sortable: true, 
               	  filter: 'text', 
               	  width: 100,
               	  align: "center",
               	},       
            	{ 
               	  header: '완제품', 
               	  name: 'pdtName', 
               	  sortable: true, 
               	  filter: 'text',
                  width: 200,
               	  align: "center",
            	},
            	{ 
            	  header: '무게 측정값', 
            	  name: 'fqcMeasuredWeightValue', 
            	  sortable: true, 
            	  filter: 'text',
            	  width: 100,
           		  align: "center",  
            	},
            	{ 
           	      header: '단위(무게)', 
           		  name: 'qcmUnitWeight', 
           		  sortable: true, 
           		  filter: 'text',
           		  width: 100,
           		  align: "center",
              	},
            	{
           	      header: '길이 측정값', 
           		  name: 'fqcMeasuredLengthValue', 
           		  sortable: true, 
           		  filter: 'text',
           		  width: 100,
           		  align: "center",
	    		},
            	{ 
           	      header: '단위(길이)', 
           		  name: 'qcmUnitLength', 
           		  sortable: true, 
           		  filter: 'text',
           		  width: 100,
           		  align: "center",
              	},
	    		{ 
           	      header: '검사 시작 시간', 
           		  name: 'fqcStartTime', 
           		  sortable: true, 
           		  filter: 'text',
           		  width: 200,
           		  align: "center",
	           		formatter: function({ value }) {
	           		    if (!value) return ''; // null, undefined, '', 0 모두 걸러짐
	
	           		    const date = new Date(value);
	           		    if (isNaN(date)) return ''; // Invalid Date도 방지
	
	           		    const year = date.getFullYear();
	           		    const month = String(date.getMonth() + 1).padStart(2, '0');
	           		    const day = String(date.getDate()).padStart(2, '0');
	           		    const hours = String(date.getHours()).padStart(2, '0');
	           		    const minutes = String(date.getMinutes()).padStart(2, '0');
	           		    
	           		    return `${year}년 ${month}월 ${day}일 ${hours}시 ${minutes}분`;
	           		}
           		},
	    		{ 
           	      header: '검사 종료 시간', 
           		  name: 'fqcEndTime', 
           		  sortable: true, 
           		  filter: 'text',
           		  width: 200,
           		  align: "center",
	           		formatter: function({ value }) {
	           		    if (!value) return ''; // null, undefined, '', 0 모두 걸러짐
	
	           		    const date = new Date(value);
	           		    if (isNaN(date)) return ''; // Invalid Date도 방지
	
	           		    const year = date.getFullYear();
	           		    const month = String(date.getMonth() + 1).padStart(2, '0');
	           		    const day = String(date.getDate()).padStart(2, '0');
	           		    const hours = String(date.getHours()).padStart(2, '0');
	           		    const minutes = String(date.getMinutes()).padStart(2, '0');
	           		    
	           		    return `${year}년 ${month}월 ${day}일 ${hours}시 ${minutes}분`;
	           		}
           		},
	    		{ 
           	      header: '출고 창고', 
           		  name: 'whsName', 
           		  sortable: true, 
           		  filter: 'text',
           		  width: 100,
           		  align: "center",
              	},
	    		{ 
           	      header: '비고', 
           		  name: 'fqcRemarks', 
           		  sortable: true, 
           		  filter: 'text',
           		  align: "center",
              	}
            ],  
          });
	    

	    
	    
	    
	    
	    // 행 아무곳이나 클릭하면 체크박스 활성화
	    grid.on('click', ev => {
	    	  const rowKey = ev.rowKey;
	    	  const isChecked = grid.getCheckedRowKeys().includes(rowKey);
	    	  if (!isChecked) {
	    	    grid.check(rowKey);
	    	  } else {
	    	    grid.uncheck(rowKey);
	    	  }
	    	});
	    
	    
	    
	    // 아무곳이나 클릭하면 상세정보 띄워주기
	    grid.on('click', ev => {
	    	  const rowKey = ev.rowKey;
	    	  const rowData = grid.getRow(rowKey);
	    	  if (!rowData) return;
	    	  
	    	  
	    	  const status = rowData.fqcInspectionStatus;
	    	  const result = rowData.fqcInspectionResult;

	    	  let color = '#6c757d'; // 기본 회색 (대기)
	    	  if (status === '진행중') {
	    	    color = '#0d6efd'; // 파랑
	    	  } 
	    	  if (status === '완료') {
	    	    color = '#198754'; // 초록
	    	  }
	    	  if (result === 'P') {
		    	    color = '#198754'; // 초록
		      }
	    	  if (result === 'F') {
		    	    color = '#dc3545'; // 빨강
		      }
	    	  
	    	  const resultLabel = result === 'P' ? '합격'
	                 			: result === 'F' ? '불합격'
	                  			: '확인불가';

			  const statusHtml = `<span style="font-weight: 600; color: ${color};"><b>${status}</b></span>`;
			  const resultHtml = `<span style="font-weight: 600; color: ${color};"><b>${resultLabel}</b></span>`;
	
	    	  const detailHtml = `
	    		  <div style="border: 1px solid #ccc; border-radius: 8px; padding: 16px; background-color: #fdfdfd;">
	    		    <div style="display: flex; flex-wrap: wrap; gap: 12px;">
	    		      ${makeDetailItem('작업 상태', statusHtml)}
	    		      ${makeDetailItem('작업 상태', resultHtml)}
	    		      ${makeDetailItem('출고 검사 코드', rowData.fqcCode)}
	    		      ${makeDetailItem('검사이름', rowData.qcmName)}
	    		      ${makeDetailItem('검수자', rowData.empName)}
	    		      ${makeDetailItem('완제품', rowData.pdtName)}
	    		      ${makeDetailItem('무게 측정값', `${rowData.fqcMeasuredWeightValue} ${rowData.qcmUnitWeight}`)}
	    		      ${makeDetailItem('길이 측정값', `${rowData.fqcMeasuredLengthValue} ${rowData.qcmUnitLength}`)}
	    		      ${makeDetailItem('검사 시작', formatDate(rowData.fqcStartTime))}
	    		      ${makeDetailItem('검사 종료', formatDate(rowData.fqcEndTime))}
	    		      ${makeDetailItem('출고 창고', rowData.whsName)}
	    		      ${makeDetailItem('비고', rowData.fqcRemarks)}

	    		    </div>
	    		  </div>
	    		`;
				function makeDetailItem(label, value) {
				  return `
				    <div style="flex: 1 1 45%; display: flex;">
				      <div style="font-weight: 600; width: 120px;">${label}</div>
				      <div style="flex: 1;">${value ?? '-'}</div>
				    </div>
				  `;
				}


	    	  document.getElementById('detailContent').innerHTML = detailHtml;
	    	});
	    
	    // 날짜 포매팅 따로 뺌
	    function formatDate(value) {
    	  if (!value) return '';
    	  const date = new Date(value);
    	  if (isNaN(date)) return '';
    	  const y = date.getFullYear();
    	  const m = String(date.getMonth() + 1).padStart(2, '0');
    	  const d = String(date.getDate()).padStart(2, '0');
    	  const h = String(date.getHours()).padStart(2, '0');
    	  const min = String(date.getMinutes()).padStart(2, '0');
    	  return `${y}년 ${m}월 ${d}일 ${h}시 ${min}분`;
    	}
        
        
        
        
        async function deleteFqc() {
  		  const checkedRows = grid.getCheckedRows();
  		  const ids = checkedRows.map(row => row.fqcNo);

  		  if (ids.length === 0) {
  		    await Swal.fire({
  		      icon: "warning",
  		      title: "삭제할 데이터를 선택해주세요."
  		    });
  		    return;
  		  }

  		  const result = await Swal.fire({
  		    title: "정말 삭제하시겠습니까?",
  		    text: `총 ${ids.length}건의 데이터를 삭제합니다.`,
  		    icon: "warning",
  		    showDenyButton: true,
  		    confirmButtonText: "삭제",
  		    denyButtonText: "취소",
  		  });

  		  if (result.isDenied) {
  		    await Swal.fire({
  		      icon: "error",
  		      title: "삭제가 취소되었습니다.",
  		    });
  		    return;
  		  }
  		  

  		  // 삭제 API 요청
  		  try {
  		    const response = await fetch('/fqc/delete', {
  		      method: 'POST',
  		      headers: {
  		        'Content-Type': 'application/json'
  		      },
  		      body: JSON.stringify({ ids: ids }) // 필요 시 선택한 ID 전달
  		    });

  		    if (!response.ok) {
  		      await Swal.fire({
  		        icon: "error",
  		        title: "삭제 처리 중 서버 오류가 발생했습니다",
  		      });
  		      throw new Error("삭제 처리 중 서버 오류");
  		    }

  		    await Swal.fire({
  		      title: "삭제가 완료되었습니다",
  		      icon: "success",
  		    });
  		    
  		      location.reload();

  		  } catch (error) {
  		    console.error('Error:', error);
  		    await Swal.fire({
  		      icon: "error",
  		      title: "삭제 처리 중 예외가 발생했습니다",
  		    });
  		  }
  		}
        
        
        
        
        
      //그리드 -> 엑셀 파일로 다운로드
    	document.getElementById('ExcelDownBtn').addEventListener('click', function () {
    	    
    		//현재 그리드 데이터 가져오기
    		const gridData = grid.getData();
    		
    		//현재 그리드의 컬럼 값 가져오기
    	    const columns = grid.getColumns();

    		//컬럼을 header와 name으로 분리
    	    const header = columns.map(col => col.header);
    	    const keys = columns.map(col => col.name);

    		//header만큼 배열 생성
    	    const exportData = [header];

    		//row값을 데이터에 저장
    	    gridData.forEach(row => {
    	        const rowData = keys.map(key => row[key]);
    	        exportData.push(rowData);
    	    });

    		//CDN 이용
    	    const worksheet = XLSX.utils.aoa_to_sheet(exportData);
    	    const workbook = XLSX.utils.book_new();

    	    XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
    	    XLSX.writeFile(workbook, 'FQC-grid-data.xlsx');
    	});
    	
    	let file;
    	let reader;
    	
    	//파일이 선택시 실행
    	document.getElementById('fileInput').addEventListener('change', function (e) {	
    		
    	    file = e.target.files[0];
    	    reader = new FileReader();
    		
    		if (!file) {
    			Swal.fire({
    	            icon: 'warning',
    	            title: '파일 없음',
    	            text: '파일을 선택해 주세요.',
    	            confirmButtonText: '확인'
    	        });
    	        return;
    		}
    	});

    	//버튼 클릭 시 선택된 엑셀 파일을 그리드에 출력
    	document.getElementById('ExcelUpBtn').addEventListener('click', function (e) {
    		
    		if (!file) {
    			document.getElementById('fileInput').click();
    	        return;
    	    }
    		
    		reader.onload = function (event) {
    			const data = new Uint8Array(event.target.result);
    		    const workbook = XLSX.read(data, { type: 'array' });

    			const firstSheetName = workbook.SheetNames[0];
    		    const worksheet = workbook.Sheets[firstSheetName];

    			console.log(worksheet);
    			
    			worksheet["A1"] = { t: "s", v: "fqcNo", r:"<t>fqcNo</t><phoneticPr fontId='1' type='noConversion'/>", h: 'fqcNo', w: 'fqcNo' };
       			worksheet["B1"] = { t: "s", v: "fqcCode", r:"<t>fqcCode</t><phoneticPr fontId='1' type='noConversion'/>", h: 'fqcCode', w: 'fqcCode' };
    			worksheet["C1"] = { t: "s", v: "qcmName", r:"<t>qcmName</t><phoneticPr fontId='1' type='noConversion'/>", h: 'qcmName', w: 'qcmName' };
    			worksheet["D1"] = { t: "s", v: "empName", r:"<t>empName</t><phoneticPr fontId='1' type='noConversion'/>", h: 'empName', w: 'empName' };
    			worksheet["E1"] = { t: "s", v: "pdtName", r:"<t>pdtName</t><phoneticPr fontId='1' type='noConversion'/>", h: 'pdtName', w: 'pdtName' };
    			worksheet["F1"] = { t: "s", v: "fqcMeasuredWeightValue", r:"<t>fqcMeasuredWeightValue</t><phoneticPr fontId='1' type='noConversion'/>", h: 'fqcMeasuredWeightValue', w: 'fqcMeasuredWeightValue' };
    			worksheet["G1"] = { t: "s", v: "qcmUnitWeight", r:"<t>qcmUnitWeight</t><phoneticPr fontId='1' type='noConversion'/>", h: 'qcmUnitWeight', w: 'qcmUnitWeight' };
    			worksheet["H1"] = { t: "s", v: "fqcMeasuredLengthValue", r:"<t>fqcMeasuredLengthValue</t><phoneticPr fontId='1' type='noConversion'/>", h: 'fqcMeasuredLengthValue', w: 'fqcMeasuredLengthValue' };
    			worksheet["I1"] = { t: "s", v: "qcmUnitLength", r:"<t>qcmUnitLength</t><phoneticPr fontId='1' type='noConversion'/>", h: 'qcmUnitLength', w: 'qcmUnitLength' };
    			worksheet["J1"] = { t: "s", v: "fqcStartTime", r:"<t>fqcStartTime</t><phoneticPr fontId='1' type='noConversion'/>", h: 'fqcStartTime', w: 'fqcStartTime' };
    			worksheet["K1"] = { t: "s", v: "fqcEndTime", r:"<t>fqcEndTime</t><phoneticPr fontId='1' type='noConversion'/>", h: 'fqcEndTime', w: 'fqcEndTime' };
    			worksheet["L1"] = { t: "s", v: "whsName", r:"<t>whsName</t><phoneticPr fontId='1' type='noConversion'/>", h: 'whsName', w: 'whsName' };
    			worksheet["M1"] = { t: "s", v: "fqcRemarks", r:"<t>fqcRemarks</t><phoneticPr fontId='1' type='noConversion'/>", h: 'fqcRemarks', w: 'fqcRemarks' };
    			
    			const jsonData = XLSX.utils.sheet_to_json(worksheet, { defval: "" });

    			// TUI Grid에 반영
    			grid.resetData(jsonData);
    	   
    	   	
    			// 바로 서버에 저장 요청
    			fetch('/fqc/saveExcelData', {
    			    method: 'POST',
    			    headers: {
    			        'Content-Type': 'application/json'
    			    },
    			    body: JSON.stringify(jsonData)
    			})
    			.then(res => {
    			    if (!res.ok) throw new Error("저장 실패");
    			    return res.text();
    			})
    			.then(data => {
    			    Swal.fire({
    			        icon: 'success',
    			        title: '업로드 완료',
    			        text: '엑셀 업로드 및 저장이 완료되었습니다.',
    			        confirmButtonText: '확인'
    			    });
    			})
    			.catch(err => {
    			    console.error(err);
    			    Swal.fire({
    			        icon: 'error',
    			        title: '저장 오류',
    			        text: '엑셀 저장 중 오류가 발생했습니다.',
    			        confirmButtonText: '닫기'
    			    });
    			});
    			
    			};

    		reader.readAsArrayBuffer(file);
    		
    	});	
    	

        
        
        
        
	  	// grid 데이터 원본 저장
	  	const originalData = grid.getData();
	
	  	document.getElementById('searchInput').addEventListener('input', function (e) {
	  	  const keyword = e.target.value.toLowerCase();
	
	  	  // 원본 데이터를 기준으로 필터링
	  	  const filtered = originalData.filter(row => {
	  	    return Object.values(row).some(val => {
	  	      if (val == null) return false;
	  	      return String(val).toLowerCase().includes(keyword);
	  	    });
	  	  });
	
	  	  // 필터링된 데이터로 그리드 업데이트
	  	  grid.resetData(filtered);
	  	});
	  	
	  	
	  	function applyFilter() {
  		  const keyword = document.getElementById('searchInput').value.toLowerCase();
  		  const start = document.getElementById('startDate').value;
  		  const end = document.getElementById('endDate').value;

  		  let filtered = originalData;

  		  if (start && end) {
  		    const startDate = new Date(start);
  		    const endDate = new Date(end);
  		    endDate.setHours(23, 59, 59, 999);

  		    filtered = filtered.filter(row => {
  		      const fqcDate = new Date(row.fqcStartDate);
  		      return fqcStartDate >= startDate && fqcStartDate <= endDate;
  		    });
  		  }

  		  if (keyword) {
  		    filtered = filtered.filter(row =>
  		      Object.values(row).some(val =>
  		        val != null && String(val).toLowerCase().includes(keyword)
  		      )
  		    );
  		  }

  		  grid.resetData(filtered);
  		}

  		document.getElementById('dateSearchBtn').addEventListener('click', applyFilter);
  		document.getElementById('searchInput').addEventListener('input', applyFilter);
  	
	</script> 
	
	
	
	
	</div>



</body>
</html>