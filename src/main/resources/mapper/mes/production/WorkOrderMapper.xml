<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- ProductMapper.java 경로로 클래스명 ProductMapper까지 입력 --> 
<mapper namespace="com.example.cmtProject.mapper.mes.production.WorkOrderMapper">
	<!-- 작업지시 목록 -->
	<select id="selectOrderList" resultType="com.example.cmtProject.dto.mes.production.WorkOrderDTO">
	<!-- 근데 여기는 MFG_SCHEDULES을 가져와야하지 않나   -->
		SELECT
			  W.WO_NO
			, W.WO_CODE
			, W.PDT_CODE
			, W.PRC_CODE
			, W.ORDER_DATE
			, W.WO_QTY
			, S.WO_STATUS_CODE
			, S.WO_STATUS_NAME
			, W.STATUS
			, W.DUE_DATE
			, W.COMMENTS
			, W.USE_YN
			, W.WO_START_DATE
 			, W.WO_END_DATE  
            , P.PDT_NAME 
            , E.EMP_NAME
            
		  FROM WORK_ORDER W 
		           JOIN PRODUCTS P ON W.PDT_CODE = P.PDT_CODE
		           JOIN EMPLOYEES E ON W.EMP_ID = E.EMP_ID
		           JOIN WORK_ORDER_STATUS S ON W.WO_STATUS_CODE = S.WO_STATUS_CODE
		 ORDER BY WORK_ORDER_NO DESC
	</select>
	<!-- 제조계획 리스트 - 모달 -->
	<select id="selectPlanList" resultType="com.example.cmtProject.dto.mes.manufacturingMgt.MfgScheduleDTO">
		SELECT 
		    S.MS_NO
		    , S.MS_CODE
		    , S.PDT_CODE
		    , P.PDT_NAME
		    , S.ALLOCATED_QTY
		    , S.MS_START_DATE
		    , S.MS_END_DATE
		    , S.EMP_ID
		    , S.MS_PRIORITY
		    , S.MS_STATUS
		    , S.MS_UPDATED_AT
		    , S.PRC_CODE
		    , S.MP_CODE
		    , S.MS_QTY
		    , S.PDT_PRC_TYPE_CODE
		FROM MFG_SCHEDULES S JOIN PRODUCTS P ON S.PDT_CODE = P.PDT_CODE
		WHERE  MS_STATUS != '대기'
		ORDER BY S.MS_NO DESC
	</select>
	<!-- 제조계획리스트 -> workOrder 테이블에 insert -->
	<insert id="insertMsPlan"  parameterType="com.example.cmtProject.dto.mes.production.WorkOrderDTO">
		INSERT INTO WORK_ORDER(
		 	WO_NO
			 , WO_CODE
			 , PDT_CODE
			 , PDT_NAME
			 , WO_QTY
			 , EMP_ID
			 , LINE_CODE
			 , PRC_CODE
			 , WORK_START_DATE
			 , WORK_END_DATE
			 , WO_STATUS_CODE -- 공정상태
		) VALUES (
				WORK_ORDER_SEQ.NEXTVAL
			, #{msCode, jdbcType=VARCHAR}
			, #{pdtCode, jdbcType=VARCHAR}
			, #{pdtName, jdbcType=VARCHAR}
			, #{allocatedQty, jdbcType=VARCHAR}
			, #{empId, jdbcType=VARCHAR}
			, #{lineCode, jdbcType=VARCHAR}
			, #{prcCode, jdbcType=VARCHAR}
			, #{msStartDate, jdbcType=DATE}
<!-- 			, #{msEndDate, jdbcType=DATE} -->
			, NULL
			,#{msStatus, jdbcType=VARCHAR}
		)
	</insert>
	<update id="updateMfgStatus">
		UPDATE WORK_ORDER
		SET WO_STATUS_CODE = (
	        SELECT WO_STATUS_CODE FROM WORK_ORDER_STATUS WHERE WO_STATUS_CODE = 'SB'
	    )
		WHERE WO_CODE = #{msCode}
	</update>
	
	<delete id="deleteMfgList">
		DELETE FROM MFG_SCHEDULES 
		WHERE MS_CODE = #{msCode}
	</delete>
	
	
	<!-- 작업시작 버튼 = 날짜 업데이트&진행중 -->
	<update id="updateWorkStartTime">
		 UPDATE WORK_ORDER
	     SET WO_START_DATE = SYSDATE 
	    	 , WO_STATUS_CODE = 'RN' 
	     WHERE WO_NO = #{woNo}
	</update>
	
	<!-- 로트번호로 단일제품 정보 들고오기 -->
	<select id="selectLotNoDetail" resultType="com.example.cmtProject.dto.mes.production.LotDTO">
		SELECT 
		    L.*, 
		    W.PDT_NAME,
		    E.EMP_NAME
		FROM 
		    LOT L
		JOIN 
		    WORK_ORDER W ON L.WO_CODE = W.WO_CODE
		LEFT JOIN 
		    EMPLOYEES E ON W.EMP_ID = E.EMP_ID
		WHERE 
		    L.LOT_NO = #{lotNo}
	</select>
	
	<!-- 로트번호 뿌리기 -->
	<select id="selectLotDetail" resultType="com.example.cmtProject.dto.mes.production.LotDTO">
		SELECT L.*,W.PDT_NAME
		FROM LOT L JOIN WORK_ORDER W ON L.WO_CODE = W.WO_CODE
	</select>
	
	
	<!-- 계층구조로 로트번호 리스트 뿌리기 -->
	<select id="selectAllLotTree" resultType="com.example.cmtProject.dto.mes.production.LotDTO">
<!-- 		SELECT -->
<!-- 	      LEVEL, -->
<!-- 	      L.LOT_NO, -->
<!-- 	      L.LOT_CODE, -->
<!-- 	      L.PDT_CODE, -->
<!-- 	      L.CHILD_PDT_CODE, -->
<!-- 	      CONNECT_BY_ISLEAF AS IS_LEAF, -->
<!-- 	      PRIOR L.LOT_CODE AS childLotCode -->
<!-- 	    FROM LOT L -->
<!-- 	    START WITH L.PDT_CODE NOT IN (SELECT CHILD_PDT_CODE FROM LOT WHERE CHILD_PDT_CODE IS NOT NULL) -->
<!-- 	     START WITH L.CHILD_PDT_CODE IS NULL -->
<!-- 	    CONNECT BY PRIOR L.PDT_CODE = L.CHILD_PDT_CODE -->
<!-- 	    ORDER SIBLINGS BY L.LOT_NO -->
			SELECT    
			    LEVEL,
			    L.LOT_NO,
			    L.LOT_CODE,
			    L.PDT_CODE,
			    L.CHILD_LOT_CODE,
			    W.PDT_NAME,
			    CONNECT_BY_ISLEAF AS IS_LEAF,
			    PRIOR L.LOT_CODE AS PARENT_LOT_CODE,
			    SYS_CONNECT_BY_PATH(L.LOT_CODE, ' → ') AS PATH
			FROM LOT L
			LEFT JOIN WORK_ORDER W ON L.PDT_CODE = W.PDT_CODE
			START WITH L.CHILD_LOT_CODE IS NULL
			CONNECT BY PRIOR L.LOT_CODE = L.CHILD_LOT_CODE
			ORDER SIBLINGS BY L.LOT_NO

	</select>
	
</mapper>